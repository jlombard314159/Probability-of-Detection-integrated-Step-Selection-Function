<<<<<<< HEAD
colnames(factorDFList[[i]]) <- gsub(".*]", "", colnames(factorDFList[[i]]))
}
newDF <- do.call(cbind.data.frame, factorDFList)
if (toConvertHabitat %in% iSSFCovars) {
iSSFCovars <- iSSFCovars[!iSSFCovars == toConvertHabitat]
iSSFCovars <- c(iSSFCovars, colnames(newDF))
}
if (toConvertHabitat %in% probDetCovars) {
probDetCovars <- probDetCovars[!probDetCovars ==
toConvertHabitat]
probDetCovars <- c(probDetCovars, colnames(newDF))
}
habitatDF <- habitatDF[, !(colnames(habitatDF) %in% toConvertHabitat)]
habitatDF <- cbind(habitatDF, newDF)
}
distMatrix <- as.matrix(x = stats::dist(cbind(habitatDF[, # why do this if you don't have to ?
colnames(habitatDF) %in% distColumns[1]], habitatDF[,
colnames(habitatDF) %in% distColumns[2]])))
if (is.null(iSSFCovars)) {
stop("A covariate must be specific for the iSSF")
} else {
habitatDFSub <- as.data.frame(habitatDF[, colnames(habitatDF) %in%
iSSFCovars])
matrixList <- list()
for (i in 1:ncol(habitatDFSub)) {
matrixList[[i]] <- matrix(habitatDFSub[, i], nrow = nCells,
ncol = nCells, byrow = T)
}
if (!is.null(distMatrix) & ("distance" %in% iSSFCovars)) {
matrixList[[length(matrixList) + 1]] <- distMatrix
}
vectorToConvert <- c()
for (i in 1:length(matrixList)) {
vectorToConvert[i] <- paste("matrixList[[", i, "]]",
sep = "")
}
formulaRest <- paste("~", paste(vectorToConvert, collapse = "+"))
selectionFormula <- as.formula(formulaRest)
}
is.null(probDetCovars)
if (is.null(probDetCovars)) {
probDetFormula <- NULL
} else {
logisticSub <- as.data.frame(habitatDF[, colnames(habitatDF) %in%
probDetCovars])
vectorToConvert <- c()
for (i in 1:ncol(logisticSub)) {
vectorToConvert[i] <- paste("logisticSub[,", i, "]",
sep = "")
}
finalFormula <- paste("~ 1 +", paste(vectorToConvert,
collapse = "+"))
probDetFormula <- as.formula(finalFormula)
}
probDetFormula
PDiSSFFit <- PDiSSFModel(selection = selectionFormula, p = probDetFormula,
locations = CellID, ncells = nCells,
maxLagArg = maxLagArg, iSSFCovar = iSSFCovars,
LogCovar = c("Intercept", probDetCovars))
probDetFormula = ""
PDiSSFFit <- PDiSSFModel(selection = selectionFormula, p = probDetFormula,
locations = CellID, ncells = nCells,
maxLagArg = maxLagArg, iSSFCovar = iSSFCovars,
LogCovar = c("Intercept", probDetCovars))
probDetFormula = c("")
PDiSSFFit <- PDiSSFModel(selection = selectionFormula, p = probDetFormula,
locations = CellID, ncells = nCells,
maxLagArg = maxLagArg, iSSFCovar = iSSFCovars,
LogCovar = c("Intercept", probDetCovars))
probDetFormula <- NULL
PDiSSFFit <- PDiSSFModel(selection = selectionFormula, p = probDetFormula,
locations = CellID, ncells = nCells,
maxLagArg = maxLagArg, iSSFCovar = iSSFCovars,
LogCovar = c("Intercept", probDetCovars))
# for PDisSFModel.R
selection = selectionFormula
p = probDetFormula
locations = CellID
ncells = nCells
maxLagArg = maxLagArg
iSSFCovar = iSSFCovars
LogCovar = c("Intercept", probDetCovars)
maxLagArg = 4
p
if (missing(selection))
stop("Model for habitat selection must be specified")
if (missing(p))
stop("Model for p (encounter probabilities) must be specified")
if (missing(locations))
stop("Animal locations must be specified")
if (max(locations, na.rm = T) > ncells)
stop("Cell ID #s are not correct")
if (!is.numeric(locations)) # Consider moving one above
=======
>>>>>>> ad0f5e79d574f06ab8ebeddae37ee6bb869d2db6
stop("Cell ID #s are not numeric")
orig.call <- match.call()
iSSF.mod.mat <- getModMatrix(selection, ncells)
X.iSSF <- iSSF.mod.mat$X
is.null(p)
if (is.null(p)) {
strt.vals <- rep(0, k.iSSF)
out <- nlminb(start = strt.vals, objective = iSSFLogLike,
X1 = X.iSSF, locations = locations, k1 = k.iSSF)
hessian = F.2nd.deriv(out$par, iSSFLogLike, X1 = X.iSSF,
locations = locations, k1 = k.iSSF)
SEs <- sqrt(diag(solve(hessian)))
iSSF.coefs <- out$par[1:k.iSSF]
iSSFDataframe <- data.frame(Covar = iSSFCovar, Coef = iSSF.coefs,
SE = SEs[1:k.iSSF])
ans <- list(loglik = -out$objective, convergence = out$convergence,
call = orig.call, ncells = ncells, n.fix.attempts = length(locations),
iSSF = iSSFDataframe, aic = 2 * out$objective + 2 *
(k.iSSF), bic = 2 * out$objective + (k.iSSF) *
log(sum(!is.na(locations)) - 1))
class(ans) <- "PDiSSF"
return(ans)
}
k.iSSF <- iSSF.mod.mat$n.covars
if (is.null(p)) {
strt.vals <- rep(0, k.iSSF)
out <- nlminb(start = strt.vals, objective = iSSFLogLike,
X1 = X.iSSF, locations = locations, k1 = k.iSSF)
hessian = F.2nd.deriv(out$par, iSSFLogLike, X1 = X.iSSF,
locations = locations, k1 = k.iSSF)
SEs <- sqrt(diag(solve(hessian)))
iSSF.coefs <- out$par[1:k.iSSF]
iSSFDataframe <- data.frame(Covar = iSSFCovar, Coef = iSSF.coefs,
SE = SEs[1:k.iSSF])
ans <- list(loglik = -out$objective, convergence = out$convergence,
call = orig.call, ncells = ncells, n.fix.attempts = length(locations),
iSSF = iSSFDataframe, aic = 2 * out$objective + 2 *
(k.iSSF), bic = 2 * out$objective + (k.iSSF) *
log(sum(!is.na(locations)) - 1))
class(ans) <- "PDiSSF"
return(ans)
}
strt.vals <- rep(0, k.iSSF)
out <- nlminb(start = strt.vals, objective = iSSFLogLike,
X1 = X.iSSF, locations = locations, k1 = k.iSSF)
warnings()
# for issFLogLike.R
start = strt.vals
objective = iSSFLogLike
X1 = X.iSSF
locations = locations
k1 = k.iSSF
k1
start
X1
iSSF.coefs <- beta[1:k1]
beta
iSSF.coefs <- beta[1:k1]
k1
X1
orig.call <- match.call()
iSSF.mod.mat <- getModMatrix(selection, ncells)
X.iSSF <- iSSF.mod.mat$X
k.iSSF <- iSSF.mod.mat$n.covars
strt.vals <- rep(0, k.iSSF)
iSSFLogLike <- function (beta, X1, locations, k1) {
iSSF.coefs <- beta[1:k1]
ncells <- nrow(X1)
fix.attempts <- length(locations)
Lag <- rep(1, times = fix.attempts)
for (i in 3:fix.attempts) {
if (is.na(locations[i - 1]))
Lag[i] <- Lag[i - 1] + 1
}
detected <- !is.na(locations)
EXP <- matrix(0, nrow = ncells, ncol = ncells)
for (i in 1:k1) {
EXP <- EXP + X1[, (1 + (i - 1) * ncells):(i * ncells)] *
iSSF.coefs[i]
}
EXP <- exp(EXP)
sumEXP <- matrix(rowSums(EXP), nrow = ncells, ncol = ncells)
D <- (EXP/sumEXP)
prob <- rep(NA, times = fix.attempts)
for (i in 2:fix.attempts) {
if (detected[i] & Lag[i] == 1) {
prob[i] <- D[locations[i - 1], locations[i]]
}
}
-sum(log(prob), na.rm = TRUE)
# print(paste("Working (", round(runif(1, 0, 100), 0), ")")) # just to show something is working think about removing this for debugging
}
out <- nlminb(start = strt.vals, objective = iSSFLogLike,
X1 = X.iSSF, locations = locations, k1 = k.iSSF)
hessian = F.2nd.deriv(out$par, iSSFLogLike, X1 = X.iSSF,
locations = locations, k1 = k.iSSF)
PDiSSFModel <- function (selection, p, locations, ncells, maxLagArg, iSSFCovar,
LogCovar) {
if (missing(selection))
stop("Model for habitat selection must be specified")
if (missing(p))
stop("Model for p (encounter probabilities) must be specified")
if (missing(locations))
stop("Animal locations must be specified")
if (max(locations, na.rm = T) > ncells)
stop("Cell ID #s are not correct")
if (!is.numeric(locations)) # Consider moving one above
stop("Cell ID #s are not numeric")
orig.call <- match.call()
iSSF.mod.mat <- getModMatrix(selection, ncells)
X.iSSF <- iSSF.mod.mat$X
k.iSSF <- iSSF.mod.mat$n.covars
if (is.null(p)) {
strt.vals <- rep(0, k.iSSF)
out <- nlminb(start = strt.vals, objective = iSSFLogLike,
X1 = X.iSSF, locations = locations, k1 = k.iSSF)
hessian = F.2nd.deriv(out$par, iSSFLogLike, X1 = X.iSSF,
locations = locations, k1 = k.iSSF)
SEs <- sqrt(diag(solve(hessian)))
iSSF.coefs <- out$par[1:k.iSSF]
iSSFDataframe <- data.frame(Covar = iSSFCovar, Coef = iSSF.coefs,
SE = SEs[1:k.iSSF])
ans <- list(loglik = -out$objective, convergence = out$convergence,
call = orig.call, ncells = ncells, n.fix.attempts = length(locations),
iSSF = iSSFDataframe, aic = 2 * out$objective + 2 *
(k.iSSF), bic = 2 * out$objective + (k.iSSF) *
log(sum(!is.na(locations)) - 1))
class(ans) <- "PDiSSF"
return(ans)
}
if (!is.null(p)) {
p.mod.mat <- getModMatrix(p, ncells)
X.p <- p.mod.mat$X
k.p <- p.mod.mat$n.covars
strt.vals <- rep(0, k.iSSF + k.p)
out <- nlminb(start = strt.vals, objective = PDiSSFLogLike,
X1 = X.iSSF, X2 = X.p, locations = locations, k1 = k.iSSF,
k2 = k.p, maxLagArg = maxLagArg)
iSSF.coefs <- out$par[1:k.iSSF]
p.coefs <- out$par[(k.iSSF + 1):(k.iSSF + k.p)]
hessian <- F.2nd.deriv(out$par, PDiSSFLogLike, X1 = X.iSSF,
X2 = X.p, locations = locations, k1 = k.iSSF,
k2 = k.p, maxLagArg = maxLagArg)
SEs <- sqrt(diag(solve(hessian)))
# iSSFDataframe <- data.frame(Covar = iSSFCovar, Coef = iSSF.coefs[order(iSSFCovar)], ### original
#     SE = SEs[1:k.iSSF])
iSSFDataframe <- data.frame(Covar = iSSFCovar, Coef = iSSF.coefs,
SE = SEs[1:k.iSSF])
LogDataframe <- data.frame(Covar = LogCovar, Coef = p.coefs,
SE = SEs[(k.iSSF + 1):(k.iSSF + k.p)])
ans <- list(loglik = -out$objective, convergence = out$convergence,
call = orig.call, n.ells = ncells, n.fix.attempts = length(locations),
iSSF = iSSFDataframe, Detection = LogDataframe, aic = 2 *
out$objective + 2 * (k.iSSF + k.p))
class(ans) <- "PDiSSF"
return(ans)
}
}
ans
library(PDiSSF)
data(habitat); head(habitat)
data(locations); head(locations)
mean(!is.na(locations$unitID))
# iSSF --------------------------------------------------------------------
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
rslts <- pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
# iSSFCovars = c("prctSage", "elevation", "distance"), # MUST BE "distance"
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 9)
rslts
# iSSF --------------------------------------------------------------------
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
# iSSF --------------------------------------------------------------------
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
# iSSF --------------------------------------------------------------------
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "elevation"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
# iSSF --------------------------------------------------------------------
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
# iSSF --------------------------------------------------------------------
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "elevation", "prctSage"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
library(MDC)
habitat$elevation_2 <- habitat$elevation^2
# iSSF --------------------------------------------------------------------
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation", "elevation_2"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
head(habitat)
hist(habitat$elevation)
habitat$elev <- habitat$elevation - mean(habitat$elevation)
# iSSF --------------------------------------------------------------------
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elev"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
library(PDiSSF)
library(MDC)
data(habitat); head(habitat)
data(locations); head(locations)
mean(!is.na(locations$unitID))
rslts <- pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
# iSSFCovars = c("prctSage", "elevation", "distance"), # MUST BE "distance"
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 9)
rslts
library(PDiSSF)
library(PDiSSF)
library(MDC)
data(habitat); head(habitat)
data(locations); head(locations)
mean(!is.na(locations$unitID))
rslts <- pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
# iSSFCovars = c("prctSage", "elevation", "distance"), # MUST BE "distance"
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 9)
rslts
# iSSF --------------------------------------------------------------------
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
habitat$prctSageCentered <- habitat$prctSage - mean(habitat$prctSage)
habitat$elevationCentered <- habitat$elevation - mean(habitat$elevation)
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSageCentered", "elevationCentered"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
library(PDiSSF)
data(habitat)
data(locations)
habitat$prctSageCentered <- habitat$prctSage - mean(habitat$prctSage)
habitat$elevationCentered <- habitat$elevation - mean(habitat$elevation)
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSageCentered", "elevationCentered"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevationCentered"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
habitat$elevationCntrd <- habitat$elevation - mean(habitat$elevation)
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevationCntrd"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
library(PDiSSF)
data(habitat); head(habitat)
data(locations); head(locations)
mean(!is.na(locations$unitID))
rslts <- pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
# iSSFCovars = c("prctSage", "elevation", "distance"), # MUST BE "distance"
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 9)
rslts
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 10)
str(locations)
missing <- ifelse(is.na(locations$unitID), 1, 0)
nAttempts <- length(locations$unitID)
lags <- rep(0, nAttempts)
for(i in 2:nAttemts){
if(missing[i] == 0){
lags[i] <- missing[i] + missing[i-1]
} else {
lags[i] <- 0
}
}
lags <- rep(0, nAttempts)
for(i in 2:nAttempts){
if(missing[i] == 0){
lags[i] <- missing[i] + missing[i-1]
} else {
lags[i] <- 0
}
}
max(lags)
sum(missing)
missing <- ifelse(is.na(locations$unitID), 1, 0)
nAttempts <- length(locations$unitID)
lags <- rep(0, nAttempts)
for(i in 2:nAttempts){
if(missing[i] == 1){
lags[i] <- missing[i] + missing[i-1]
} else {
lags[i] <- 0
}
}
max(lags)
locations
missing
missing <- ifelse(is.na(locations$unitID), 1, 0)
nAttempts <- length(locations$unitID)
sinceFix <- rep(0, nAttempts)
for(i in 2:nAttempts){
if(missing[i] == 1){
sinceFix[i] <- missing[i] + missing[i-1]
} else {
sinceFix[i] <- 0
}
}
max(sinceFix)
sinceFix
missing <- ifelse(is.na(locations$unitID), 1, 0)
nAttempts <- length(locations$unitID)
sinceFix <- rep(0, nAttempts)
for(i in 2:nAttempts){
if(missing[i] == 1){
sinceFix[i] <- missing[i] + sinceFix[i-1]
} else {
sinceFix[i] <- 0
}
}
max(sinceFix)
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 4)
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 3)
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 2)
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 1)
library(PDiSSF)
data(habitat)
data(locations)
# Fix success rate
mean(!is.na(locations$unitID))
# Computing time for larger data sets may vary WIDELY
# integrated step selection function (iSSF) using step length
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
# error in hessian: NaN for SE of elevation
# center elevation to fix
habitat$elevationCntrd <- habitat$elevation - mean(habitat$elevation)
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevationCntrd"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
# PDiSSF with prctSage as covariate for probability of detection
# calculate maximum number consecutive missing locations
missing <- ifelse(is.na(locations$unitID), 1, 0)
nAttempts <- length(locations$unitID)
sinceFix <- rep(0, nAttempts)
for(i in 2:nAttempts){
if(missing[i] == 1){
sinceFix[i] <- missing[i] + sinceFix[i-1]
} else {
sinceFix[i] <- 0
}
}
max(sinceFix) # set maxLagArg to 3 or lower
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 3)
375/3174
375/(375+1664)
375+1664
2039/3174
1664/3174
<<<<<<< HEAD
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
=======
data(habitat)
data(locations)
# Fix success rate
mean(!is.na(locations$unitID))
# Computing time for larger data sets may vary WIDELY
# integrated step selection function (iSSF) using step length
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
# error in hessian: NaN for SE of elevation
library(PDiSSF)
data(habitat)
data(locations)
# Fix success rate
mean(!is.na(locations$unitID))
# Computing time for larger data sets may vary WIDELY
# integrated step selection function (iSSF) using step length
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = NULL,
distColumns = c("utmX","utmY"))
# error in hessian: NaN for SE of elevation
missing <- ifelse(is.na(locations$unitID), 1, 0)
nAttempts <- length(locations$unitID)
sinceFix <- rep(0, nAttempts)
for(i in 2:nAttempts){
if(missing[i] == 1){
sinceFix[i] <- missing[i] + sinceFix[i-1]
} else {
sinceFix[i] <- 0
}
}
max(sinceFix) # set maxLagArg to 3 or lower
pdissf(habitatDF = habitat,
CellID = locations$unitID,
iSSFCovars = c("distance", "prctSage", "elevation"),
probDetCovars = "prctSage", distColumns = c("utmX","utmY"), maxLagArg = 3)
library(PDiSSF)
?PDiSSF
?locations
library(PDiSSF)
?pdissf
library(PDiSSF)
?pdissf
library(PDiSSF)
?pdissf
library(PDiSSF)
?pdissf
library(PDiSSF)
library(PDiSSF)
?pdissf
library(PDiSSF)
?pdissf
library(PDiSSF)
?pdissf
library(PDiSSF)
?pdissf
library(PDiSSF)
library(PDiSSF)
?pdissf
library(PDiSSF)
?pdissf
summary(habitat)
data("habitat")
summary(habitat)
data("locations")
summary(locations)
a <- 1:1000
b <- sample(a, 10, replace = TRUE)
b
a <- 1:10
b <- sample(a, 10, replace = TRUE)
b
sum(b %in% a)
b <- b + 13
sum(b %in% a)
b <- sample(a, 10, replace = TRUE)
b <- c(b, 13)
sum(b %in% a)
?clock
Sys.time()
for(i in 1:1000){
print(paste(i, "\r"))
}
for(i in 1:1000){
print(paste(i, " \r"))
}
for(i in 1:1000){
paste(i, " \r")
}
for(i in 1:1000){
cat(paste(i, " \r"))
}
for(i in 1:10000000){
cat(paste(i, " \r"))
}
>>>>>>> ad0f5e79d574f06ab8ebeddae37ee6bb869d2db6
